用户数异常监控

---任务设置
按钮:添加检查任务
检查项，检查网元个数，执行开始时间，执行结束时间，间隔时长（分钟），创建者，任务状态（未启动，启动），停止/启动，查看检查任务，修改检查任务
按钮:添加检查任务，添加任务时，如果网元已经在其他任务中被选择则需要提示
任务名称：
时间设置：可编辑下拉框，每隔（5-30，每分钟都要）分执行，输入的必须为5-30之间的数字。
执行开始时间：选择小时，分钟，默认是当前小时和分钟
执行结束时间：选择小时，分钟（最后一次执行时间以实际轮循执行时间为准。）
按钮：保存 取消

绑定网元
网元名称 查询
网元名称，绑定状态，操作（绑定，取消绑定，未绑定的显示绑定按钮，已经绑定的显示取消绑定按钮，绑定的网元前置）

查看检查任务：
上述条件不可编辑。
修改检查任务：可修改上述内容，前提是停止任务后才可修改，只对下次任务生效。



---任务结果查看
日期，任务开始时间，任务结束时间，检查网元个数，用户数为0的网元个数（不为0则用红色标示），查看详细（根据任务ID查找用户数结果表，按照用户数排序）






创建表：
1.任务表：ID,执行开始时间，执行结束时间，间隔时间，状态（1激活，0停止），网元列表ID，检查项ID，创建者，下次任务执行时间   getUsersExceptionForList(String neName);
2.任务明细表：任务ID，日期，任务开始时间，任务结束时间，任务状态（正在执行，执行成功，执行失败，0为正在执行，1为执行成功 ，不为1则表示部分调用决策树失败），执行网元个数，用户数为0的网元个数  getUsersExceptionDetailForList(String taskId);
3.任务网元列表：ID，任务ID，网元ID，网元名称
4.用户数结果表：任务明细ID，网元ID，网元名称，用户数
5.检查项表：ID，检查项ID，命令名称， lua名称，检查项名称。

逻辑：
用户先配置好任务及对应的网元，激活任务后，到了执行时间，生成任务明细，并将任务明细ID，网元ID，ZEEI命令发送给集中操作，集中操作收到请求后执行ZEEI命令，分析用户数，如果为0则调用决策树发送短信，
并将任务明细ID，用户数及网元ID写入数据库。

自动为表创建分区。
数据清理：
保留一个月的数据，每天清理一次30天前的数据（任务明细表）


停止任务：修改表状态，发送消息给任务队列移除该任务。
启动任务，修改表状态，发送消息给任务队列添加该任务。

周五：安装软件，搭建环境
周一：理设计思路，及界面构成
周二：设计表，创建查询接口，完成任务查询。
周三：完成任务添加界面及功能，完成绑定网元界面及绑定网元界面查询部分功能
周四：完善绑定网元界面查询，完成绑定网元和解绑网元功能，完成任务结果界面及搜索功能，完成网元结果查看
周五：测试。 
1.绑定网元分页问题：已解决
2.任务分页问题：已解决
3.任务列表按钮及数据不能对齐的问题：无法解决
4.由于无法解决问题3，下午决定先尝试定时任务
定时任务：考虑做一个定时任务工厂，专门负责处理定时任务，
需要请求的人将任务名称，任务时间参数（类似quartz表达式），调用第三方接口地址，第三方接口参数，回调地址传入
工厂负责分配资源，创建定时任务，调用第三方接口，
5.统一通知管理报错：代码不完整或者以前修改后未提交。已修改。

流程：
WEB 定时（如每隔5分钟）将 ：网元名称，网元ID，任务明细ID，短信通知人的手机号码 发送给检查登录用户数决策树，决策树调用集中操作登录网元，解析报文获取结果，判断结为0则发送短信，



优化：
1.程序优化：
   1.1绑定网元时检查是否已经有其他激活任务绑定了该网元，有则提醒--已完成
   1.2启动任务时，检查相同间隔时间内是否有其他激活任务绑定了任务对应的网元，有则提醒。----此项暂时不设置。仅仅在绑定网元时提醒。
   1.3需要定时清理数据任务结果表的数据（考虑是否有必要：如果只是少量网元则不需要）
2.数据库优化
 2.1设置索引




下周一：设计定时任务/优化查询

截止到周四下班：完成了所有页面的开发及功能实现，剩余功能：启动任务/停止任务，计划周五先将页面全部调优（加颜色，调高宽，调按钮），然后开始开发。


周一（2017-9-25）计划用三天时间搞定定时任务
设计定时任务，包含：调用 ，回调

调用，定义线程池，存放触发的定时任务，调用决策树：
【
      2.2.1如果不选择任务开始时间和结束时间（不选择则默认为0点0分），则从点击“启动任务”按钮开始，任务启动并每隔循环周期自动执行任务；
	   调用定时任务时，仅仅需要设置循环时间
      2.2.2如果选择了开始时间，没有选择结束时间，则任务从开始时间启动，每隔循环周期自动执行；
	  调用定时任务时，需要设置开始时间和循环时间
      2.2.3如果选择了开始时间和结束时间，则每天从开始时间启动任务，每隔循环周期自动执行，直到结束时间停止任务。
	  调用定时任务时，需要设置开始时间，结束时间和循环时间
	  
	   1.用户点击启动任务按钮后，定义任务ID，明细定时任务，包含明细定时任务ID，对应的网元列表，间隔时长，停止时间等，生成一个job
	  
	   2.定义一个jobDetail，设置队列，根据1中的参数，调用决策树，等待全部返回后，更新数据库，并根据时间设置，修改当前任务的触发时间条件。
	   
	   3.系统启动时，去数据库中读取设置为启动的定时任务，循环并设置为定时任务，加载到内存中定时执行。当用户删除某个任务时，从内存中删除该任务，并修改数据库该任务状态，使下次启动时不再加载。
	     当用户新添加某个任务时，修改数据库，并生成任务。
	

】
回调：收到回调后删除线程池的线程


周二：昨天研究了QUARTZ2.2，已经可以实现这三种需求。但项目中用的是1.6，今天计划用1.6再试试。
测试成功后，将做如下工作：

项目启动时，去数据表中查找需要执行的定时任务，加入scheduler中。
定义jobDetail,传入每个任务对应的任务明细绑定到JobDataMap中。
在jobDetail执行类中，根据绑定的明细，调用决策树，并将任务明细传送到决策树。决策树将明细数据入库到数据库。
当用户在客户端启动任务时，将任务设置成新的trigger，加入scheduler中。
当用户在客户端停止任务时，将任务从scheduler中移除。

方案一：
前台联合网元表，结果表，展示每个任务绑定的网元个数，失败个数（有可能影响效率）

查询效率问题，考虑第二种方案：
在调用决策树之前，将任务ID，任务明细ID，网元列表存到MAP中,在MAP中以（任务ID#明细ID）为key，网元列表为value,决策树写完数据库后回调，在回调实现类中，根据任务ID#明细ID，查找LIST中的网元列表，有则删除。
再定义一个MAP，记录任务ID#明细ID，成功的网元个数（考虑超时情况，根据回调中的用户数，有且大于0则成功），待全部返回后（或者超时未返回），根据任务明细ID，更新网元个数，失败的网元个数（网元个数-成功的网元个数）。
并将Map中等待处理的数据清理掉。如果决策树超时后再回调则不处理？--------存在准确性问题


第三种方案：
创建内存表，将任务明细表，结果表的数据读入内存，每次执行任务时，更新内存表中的任务明细表，并更新内存表的数据。------有可能存在时效问题。比如新入库的数据未能及时读入内存。


综合考虑，还是选择第一种方案，省时省力，但查询效率会存在问题。暂时先用方案1.后台查询和前台界面已修改。
9:40 开始学习quartz1.6如何设置自定义定时任务。
9:43  先将quartz2.2的listener学习完
10:05 quartz2.2的listener创建成功，开始学习

考虑到：用户如果选择10:30到15:15分，每隔5分钟执行一次，怎么表达？是否只允许用户选择整点，不允许选择分钟。
        10:31如何表达执行完成？绑定的网元个数+失败的网元个数相等，则表示执行完成？还是调用完决策树表示执行完成？
		10:35：如果绑定的网元个数=执行的网元个数，则表示执行完成，否则在执行中
		10:44：在执行结果里，users如果为-1表示调用决策树失败，如果为-2表示登录网元失败或者解析失败
		15:51 已经在代码用quartz1.6中实现了接口的功能，但是存在以下问题：
		 1.服务重启（断电等因素），将导致任务中断，如果正在调用决策树去查看某些网元，但是任务中断，导致一些网元没有调用到，如何处理？考虑用线程检测的方式，10分钟检测一次，假设有，则生成明细数据插入到数据库结果表。
		 但这还会有问题，假设决策树调用超过10分钟才返回，并插入数据库，如何处理重复数据的问题?
		 
		没有检查完的数据无法查看明细。用户只有查看下次的数据。
		网上说quartz1.6存在很多问题。该如何处理？如果换成 quartz2，则修改量巨大，因为quartz2需要spring3以上版本支持。
		
		考虑升级spring 3.0 ，升级quartz1.6为quartz2.2
周三：早上开始编写逻辑，放弃了quartz2.2（月底前做完，升级要调试的太多，时间来不及）
方案确定：
在调用决策树时不再判断是否调用成功，---还是需要判断。
以前的做法是，调用决策树树之前先入库，然后决策树返回时再将数据移动到结果表。
现在的做法是，调用决策树，由决策树将数据入库。前台根据入库的数据多少来动态查询。
如果改成每10秒检测一次明细表中执行网元数<任务网元数且任务为激活的数据，然后到明细表中去查询执行网元，更新数据的话，是否可行、
今日修改：当调用决策树失败时，写一条明细数据到数据库。
在调用决策树之前，将用户手机号码发过去，多个号码用分号隔开

15:47 今天进展顺利，已经可以在页面启动任务，后台调度触发了。
下一步：测试三种情况是否都能触发
16:22 测试能触发，OK
现在要做的是设置静态块，启动时去数据库加载已经启动的任务放入schedule。
当用户在界面点击停止任务时，根据ID在schedule中删除该数据
16:46测试成功，已经可以在启动时加载这些任务

明日计划：处理异常情况
1.应用重启
2.决策树入库延时
3.测试停止任务时这些任务是否被停止

周四：测试
1.测试停止任务时这些任务是否被停止
8:53出错了，停止再启动时报Calendar已经存在
8:55尝试在停止任务时删除calender，如果不行就在停止任务时设置暂停任务，启动时设置恢复任务-----停止任务时删除Calender后OK
9:04前台结果界面时间不对。---查询时时间格式不对
9:10按时间查询结果不对---判断表达式错误
9:20想要修改extjs的控件（在360浏览器中横满屏）---这个后面有时间再做
2.测试加载任务时是否重复加载---9:24 没有重复加载

3.测试调用决策树时，数据源是否能被读到（是否能加载该网元异常时需要通知的人的手机号码），有可能空指针异常，无法加载决策树处理类，考虑在业务类中添加获取决策树处理类的方法？
9:30空指针异常，考虑别的获取方式 已经实现

5.给已经绑定网元的按钮文字加绿色

6.可能需要的优化：
6.1时间查询需要小时分钟
6.2可以修改任务时间----个人觉得如果正式使用应该不需要，可以删除一个任务重新设置




12:06查询页面结果问题：无按钮，检测是否是定时任务引起
12:19问题解决






回调：写数据库 or 仅判断


4.调用决策树时参数需要与王永强确定。
7.回调问题，超时未返回处理：

确定由决策树回调后写入明细数据入库
明细数据为一个任务中的一个网元一条数据

12:47开始准备设计调用和回调

决策树树会返回网元的用户数
接收到消息后，将用户数等信息写入result库
ConcurrentHashMap

创建 taskResultMap，在调用决策时，将detailId作为主键，List<TaskBsc>作为值，存入静态map.
创建 failedNeMap 将 detailId+bsc_id作为主键，failed_ne_count作为value ,存入静态map.
创建 detailMap将 detailId+bsc_id作为主键，ne_count作为value ,存入静态map.


1.决策树返回时
a)根据detailId+bsc_id找到这条记录，更新users字段和failed_info的值，将这条记录的值存入result数据库，并删除map中这条记录。
  根据detailId,查找taskResultMap，得到list后，删除
  ---放弃。
  
b)detailId+bsc_id找到failedNeMap中对应的值，value+1。
c)detailId+bsc_id找到detailMap中对应的值，如果value-1=0，则删除failedNeMap中对应的记录，删除detailMap中对应的记录，更新detail表的记录为执行完成，并更新时间,在上述 map中获取失败网元个数更新
d)调用决策树时，如果调用决策树失败，则与调用决策是返回时一样处理，a)步骤的用户记录数改为-1
e)调用决策树时，如果参数错误，则与调用决策是返回时一样处理，a)步骤的用户记录数改为-1

13:12 支持云南的迁移工作，上述任务终止









15：17 定义一个处理类用于处理调用决策树的数据
BscUsersExecuter
处理数据，调用决策树


周五：
2017-9-29 12:31写完回调处理，但是回调参数如何设置？和永强讨论了一下，他正在看代码
接下来处理异常中断的情况，比如超时未调用
设置一个5分钟的定时任务:
查询数据库，查询ices_users_task_detail中时间为NULL的数据，当前时间-任务开始时间>=5分钟 且task_status=0的数据，更新task_status=1，failed_ne_count=ne_count-已经执行的网元个数。
查询数据库，联合bsc表查询，获得未执行的bsc数据，insert到result表中，user为-1,failed_info 设置为"超时未处理"



从静态detailMap中删除这个任务，从failedNeMap中删除这个任务

14:57 发现任务不是以 detailId+bsc_id作为主键 ，而是任务ID+任务名称。怎么回事。--应该没有问题，任务作为基础执行多次
15:01好像乱了，记不得如何设计的

设计有问题，应该用detailId作为主键，来记录失败个数和网元总个数
15：50 完成异常处理的编写，准备测试。
16;04 出现 空指针异常，对象无法获取到
16:10出现 自定义5分钟的定时任务被执行多次
16:38空指针异常未解决。
16:40改为detailId+bsc_id  主键，每个BSC一个调用决策树的任务
16:58 已经初步定位问题是插入后未SET值到原有对象

下一步：检测定时任务是否正常运行

周六：
早上已经处理了周五发现的BUG
每次调用决策树都重新建立webservice链接，这样的设计是否有问题

ReturnMessage: record 

14:37还在调试调用决策树,可以调通了。之前一直报空指针异常是因为TYPE字段指定的值是决策树名称，决策树那边没有这个名称

遗留问题，需要检查 detailId+bsc_id为键的记录


2017-10-9

回调问题：回调时，是否需要判断缓存中有此数据。
系统每隔5分钟检索超时的数据，是否有冲突，如果没有冲突，则不用判断。如果有冲突，则需要判断。
---目前已经判断，比如WEB重启，数据没有了，决策传过来则不处理。这样对不对
在明细里是否需要加时间戳

--上述问题已经解决。
中午高洁想要做一个跟踪license申请的流程，目前都是邮件发来发去。我给她提到在系统中跟踪，她想要做一个小应用来记录，让相关人员在系统中操作。
想要让我做一个demo，但是目前用到的都是新的js框架，我没用过，要另一个女生做了。
14：:44 目前调用和回调接口都调通。但是决策树无法返回参数。永强正在调试。
14:45 决定把代码合并和提交一下。




15:00

流程大概是这样

内部流程系统

1.license 申请流程

点击license 申请图标后打开license申请流程页面，页面类似word文档，自动生成文档编号，申请人；可以选择产品及发布地区（与当前用户绑定），直属领导，相关领导审批均与当前申请人绑定。
下方动态展示审批流程、流程审批人及状态
如：
当前申请人----》直属领导（审核申请资质）---》相关领导审批（审批产品、限用日期、版本等）--》license负责人（生成license文件，作为附件上传）---》申请人（下载，安装，反馈）--》直属领导（如果license不能用，则返回license负责人从新生成）---》流程结束。



直属领导及申请人可以查看和下载license附件。

数据库记录相关流程，审批日期，通过MQ的方式向license管理系统发送一条消息，以记录license相关信息。
可以通过短信或邮件的形式通知相关人员审批




2017-10-10
昨天晚上看到邮件说割接的网元要使用不同的公式，让提供老公式，但是老公式我已经没有文件了。需要从代码中整理。

可能需要重新设计以前的逻辑

1.根据OMC的版本，每个版本使用不同的公式。
2.每个KPI的基础计算都存放在表里或者配置文件里。在程序启动时加载到缓存中。
3.根据OMC的版本，查找基础公式，根据基础公式生成SQL，查询OMC。


14:48 已经整理完公式和发邮件了。
接下来考虑如何设计以前的逻辑（必要性）。

a.整理分子，分母，获取的表名，附加值，GROUP BY 信息，适用OMC版本

b.整理每个KPI的分子，分母，查询参数，公式，如k=a/b*100

从新设计KPI表，为KPI单独做一张表。
包含字段：KPI名称，KPI ID，单位，公式，阈值，最低阈值，最高阈值，一到⑤轮判断的阈值及分钟，休眠时间等，参见ICES_EXCEPTION_RULE。



程序设计：
1.根据OSS版本，到a表中获取分子，分母，附加值，表名，GROUP BY 信息，组合SQL，查询OMC，将得到的结果按照BTS,TRX,BSC LOAD到本地文件




2017-10-12
由于决策树不能调试，永强单独写程序，预计今天下午可以再次调试。
开始NODE.JS的学习


vs CODE :文本编译器，以后可以不用nodepad++了。

11：20 开始学习GIT

GIT 

1.git status 获取状态（增删改）
2.git add . 把文件修改添加到暂存区；单个文件可以 用 git add readme.txt，所有可以用git add .
3.git commit -m "提交的内容描述" 把暂存区的所有内容提交到当前分支
4.git pull 从远程获取最新版本并merge到本地
5.git status 查看服务器与本地的更新对照
6.git push 将本地更新内容提交到服务器分支
7.git fetch：相当于是从远程获取最新版本到本地，不会自动merge
  git log -p master..origin/master 比较本地的master分支和origin/master分支的差别
  git merge origin/master 合并
  相当于：
  git fetch origin master:tmp
  git diff tmp 
  git merge tmp
8.git pull origin master 相当于git fetch 和 git merge 在实际使用中，git fetch更安全一些。
9.git reset --hard HEAD^ 回退到上个版本，上上个是 HEAD^^，3个是HEAD~3
  回退后，如果想回到当前版本，可以用
  git reset --hart commitID(最后一次提交的ID）。
  git log 记录每次提交的内容及ID，ID可用于回退的版本
  如；git reset --hard b412f19
  如果忘记了ID，可以用git reflog查找commitID.它记录你的每一次操作命令。
10.git checkout --file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，
   我们在后面的分支管理中会再次遇到git checkout命令。
   如果文件修改后还没有放到暂存区，则退回到工作区的版本。
   如果文件修改后已经添加到暂存区，但又做了修改，则退回到暂存区版本。
11.git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区
   如果要回退暂存区的内容，则这样做：
   a)执行
     git reset HEAD 1.txt，将暂存区的修改撤销掉。
   b)执行
     git checkout -- 1.txt ，将丢弃修改。

2017-10-16
12:13：早上调试了云南BSC系统，能发送消息到AMQ，AMQ能接收，但是还无法返回，永强正在调试。
在此期间，更新了dhss 系统，但是出错。未全部找到原因。准备下午找大曲帮忙看看。
先了解一下docker 和  elk














